import{is as t,toArray as e,eachProp as s,getFluidValue as n,isAnimatedString as i,Globals as o,useIsomorphicLayoutEffect as r,each as a,easings as c,raf as u,flush as l,FluidValue as d,deprecateInterpolate as h,callFluidObservers as f,frameLoop as p,hasFluidValue
as m,flushCalls as g,isEqual as y,getFluidObservers as _,addFluidObserver as v,removeFluidObserver as P,noop as b,useMemoOne as S,deprecateDirectCall as w,useForceUpdate as x,usePrev as I,useOnce as k,useConstant as A,onScroll as C,onResize as T,createInterpolator
as R,createStringInterpolator as E}from"@react-spring/shared";export{Globals,createInterpolator,easings,useIsomorphicLayoutEffect,useReducedMotion}from"@react-spring/shared";import*as V from"react";import{useContext as j,useMemo as U,useRef as O,useState
as q}from"react";import{getAnimated as F,AnimatedValue as M,getPayload as Q,AnimatedString as L,getAnimatedType as N,setAnimated as z}from"@react-spring/animated";export*from"@react-spring/types/animated";export*from"@react-spring/types/interpolation";function
_extends(){_extends=Object.assign?Object.assign.bind():function(t){for(var e=1;e
<arguments.length;e++){var s=arguments[e];for(var n in s)Object.prototype.hasOwnProperty.call(s,n)&&(t[n]=s[n])}return t};return _extends.apply(this,arguments)}function callProp(e,...s){return
    t.fun(e)?e(...s):e}const matchProp=(s,n)=>true===s||!!(n&&s&&(t.fun(s)?s(n):e(s).includes(n)));const resolveProp=(e,s)=>t.obj(e)?s&&e[s]:e;const getDefaultProp=(t,e)=>true===t.default?t[e]:t.default?t.default[e]:void 0;const noopTransform=t=>t;const getDefaultProps=(e,s=noopTransform)=>{let n=D;if(e.default&&true!==e.default){e=e.default;n=Object.keys(e)}const
    i={};for(const o of n){const n=s(e[o],o);t.und(n)||(i[o]=n)}return i};const D=["config","onProps","onStart","onChange","onPause","onResume","onRest"];const W={config:1,from:1,to:1,ref:1,loop:1,reset:1,pause:1,cancel:1,reverse:1,immediate:1,default:1,delay:1,onProps:1,onStart:1,onChange:1,onPause:1,onResume:1,onRest:1,onResolve:1,items:1,trail:1,sort:1,expires:1,initial:1,enter:1,update:1,leave:1,children:1,onDestroyed:1,keys:1,callId:1,parentId:1};function
    getForwardProps(t){const e={};let n=0;s(t,((t,s)=>{if(!W[s]){e[s]=t;n++}}));if(n)return e}function inferTo(t){const e=getForwardProps(t);if(e){const n={to:e};s(t,((t,s)=>s in e||(n[s]=t)));return n}return _extends({},t)}function computeGoal(e){e=n(e);return
    t.arr(e)?e.map(computeGoal):i(e)?o.createStringInterpolator({range:[0,1],output:[e,e]})(1):e}function hasProps(t){for(const e in t)return true;return false}function isAsyncTo(e){return t.fun(e)||t.arr(e)&&t.obj(e[0])}function detachRefs(t,e){var s;null==(s=t.ref)?void
    0:s.delete(t);null==e?void 0:e.delete(t)}function replaceRef(t,e){if(e&&t.ref!==e){var s;null==(s=t.ref)?void 0:s.delete(t);e.add(t);t.ref=e}}function useChain(t,e,s=1e3){r((()=>{if(e){let n=0;a(t,((t,i)=>{const o=t.current;if(o.length){let r=s*e[i];isNaN(r)?r=n:n=r;a(o,(t=>{a(t.queue,(t=>{const
    e=t.delay;t.delay=t=>r+callProp(e||0,t)}))}));t.start()}}))}else{let e=Promise.resolve();a(t,(t=>{const s=t.current;if(s.length){const n=s.map((t=>{const e=t.queue;t.queue=[];return e}));e=e.then((()=>{a(s,((t,e)=>a(n[e]||[],(e=>t.queue.push(e)))));return
    Promise.all(t.start())}))}}))}}))}const G={default:{tension:170,friction:26},gentle:{tension:120,friction:14},wobbly:{tension:180,friction:12},stiff:{tension:210,friction:20},slow:{tension:280,friction:60},molasses:{tension:280,friction:120}};const
    B=_extends({},G.default,{mass:1,damping:1,easing:c.linear,clamp:false});class AnimationConfig{constructor(){this.tension=void 0;this.friction=void 0;this.frequency=void 0;this.damping=void 0;this.mass=void 0;this.velocity=0;this.restVelocity=void
    0;this.precision=void 0;this.progress=void 0;this.duration=void 0;this.easing=void 0;this.clamp=void 0;this.bounce=void 0;this.decay=void 0;this.round=void 0;Object.assign(this,B)}}function mergeConfig(e,s,n){if(n){n=_extends({},n);sanitizeConfig(n,s);s=_extends({},n,s)}sanitizeConfig(e,s);Object.assign(e,s);for(const
    t in B)null==e[t]&&(e[t]=B[t]);let{mass:i,frequency:o,damping:r}=e;if(!t.und(o)){o
    <.01&&(o=.01);r<0&&(r=0);e.tension=Math.pow(2*Math.PI/o,2)*i;e.friction=4*Math.PI*r*i/o}return e}function sanitizeConfig(e,s){if(t.und(s.decay)){const n=!t.und(s.tension)||!t.und(s.friction);if(n||!t.und(s.frequency)||!t.und(s.damping)||!t.und(s.mass)){e.duration=void
        0;e.decay=void 0}n&&(e.frequency=void 0)}else e.duration=void 0}const K=[];class Animation{constructor(){this.changed=false;this.values=K;this.toValues=null;this.fromValues=K;this.to=void 0;this.from=void 0;this.config=new AnimationConfig;this.immediate=false}}function
        scheduleProps(e,{key:s,props:n,defaultProps:i,state:r,actions:a}){return new Promise(((c,l)=>{var d;let h;let f;let p=matchProp(null!=(d=n.cancel)?d:null==i?void 0:i.cancel,s);if(p)onStart();else{t.und(n.pause)||(r.paused=matchProp(n.pause,s));let e=null==i?void 0:i.pause;true!==e&&(e=r.paused||matchProp(e,s));h=callProp(n.delay||0,s);if(e){r.resumeQueue.add(onResume);a.pause()}else{a.resume();onResume()}}function
        onPause(){r.resumeQueue.add(onResume);r.timeouts.delete(f);f.cancel();h=f.time-u.now()}function onResume(){if(h>0&&!o.skipAnimation){r.delayed=true;f=u.setTimeout(onStart,h);r.pauseQueue.add(onPause);r.timeouts.add(f)}else onStart()}function onStart(){r.delayed&&(r.delayed=false);r.pauseQueue.delete(onPause);r.timeouts.delete(f);e
        <=(r.cancelId||0)&&(p=true);try{a.start(_extends({},n,{callId:e,cancel:p}),c)}catch(t){l(t)}}}))}const
            getCombinedResult=(t,e)=>1==e.length?e[0]:e.some((t=>t.cancelled))?getCancelledResult(t.get()):e.every((t=>t.noop))?getNoopResult(t.get()):getFinishedResult(t.get(),e.every((t=>t.finished)));const getNoopResult=t=>({value:t,noop:true,finished:true,cancelled:false});const
            getFinishedResult=(t,e,s=false)=>({value:t,finished:e,cancelled:s});const getCancelledResult=t=>({value:t,cancelled:true,finished:false});function runAsync(e,n,i,r){const{callId:a,parentId:c,onRest:l}=n;const{asyncTo:d,promise:h}=i;return
            c||e!==d||n.reset?i.promise=(async()=>{i.asyncId=a;i.asyncTo=e;const f=getDefaultProps(n,((t,e)=>"onRest"===e?void 0:t));let p;let m;const g=new Promise(((t,e)=>(p=t,m=e)));const bailIfEnded=t=>{const e=a
            <=(i.cancelId||0)&&getCancelledResult(r)||a!==i.asyncId&&getFinishedResult(r,false);if(e){t.result=e;m(t);throw
                t}};const animate=(e,n)=>{const c=new BailSignal;const u=new SkipAnimationSignal;return(async()=>{if(o.skipAnimation){stopAsync(i);u.result=getFinishedResult(r,false);m(u);throw u}bailIfEnded(c);const l=t.obj(e)?_extends({},e):_extends({},n,{to:e});l.parentId=a;s(f,((e,s)=>{t.und(l[s])&&(l[s]=e)}));const
                d=await r.start(l);bailIfEnded(c);i.paused&&await new Promise((t=>{i.resumeQueue.add(t)}));return d})()};let y;if(o.skipAnimation){stopAsync(i);return getFinishedResult(r,false)}try{let s;s=t.arr(e)?(async t=>{for(const e of t)await animate(e)})(e):Promise.resolve(e(animate,r.stop.bind(r)));await
                Promise.all([s.then(p),g]);y=getFinishedResult(r.get(),true,false)}catch(t){if(t instanceof BailSignal)y=t.result;else{if(!(t instanceof SkipAnimationSignal))throw t;y=t.result}}finally{if(a==i.asyncId){i.asyncId=c;i.asyncTo=c?d:void 0;i.promise=c?h:void
                0}}t.fun(l)&&u.batchedUpdates((()=>{l(y,r,r.item)}));return y})():h}function stopAsync(t,e){l(t.timeouts,(t=>t.cancel()));t.pauseQueue.clear();t.resumeQueue.clear();t.asyncId=t.asyncTo=t.promise=void 0;e&&(t.cancelId=e)}class BailSignal
                extends Error{constructor(){super("An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise.");this.result=void 0}}class SkipAnimationSignal extends Error{constructor(){super("SkipAnimationSignal");this.result=void
                0}}const isFrameValue=t=>t instanceof FrameValue;let Y=1;class FrameValue extends d{constructor(...t){super(...t);this.id=Y++;this.key=void 0;this._priority=0}get priority(){return this._priority}set priority(t){if(this._priority!=t){this._priority=t;this._onPriorityChange(t)}}get(){const
                t=F(this);return t&&t.getValue()}to(...t){return o.to(this,t)}interpolate(...t){h();return o.to(this,t)}toJSON(){return this.get()}observerAdded(t){1==t&&this._attach()}observerRemoved(t){0==t&&this._detach()}_attach(){}_detach(){}_onChange(t,e=false){f(this,{type:"change",parent:this,value:t,idle:e})}_onPriorityChange(t){this.idle||p.sort(this);f(this,{type:"priority",parent:this,priority:t})}}const
                X=Symbol.for("SpringPhase");const $=1;const J=2;const H=4;const hasAnimated=t=>(t[X]&$)>0;const isAnimating=t=>(t[X]&J)>0;const isPaused=t=>(t[X]&H)>0;const setActiveBit=(t,e)=>e?t[X]|=J|$:t[X]&=~J;const setPausedBit=(t,e)=>e?t[X]|=H:t[X]&=~H;class
                SpringValue extends FrameValue{constructor(e,s){super();this.key=void 0;this.animation=new Animation;this.queue=void 0;this.defaultProps={};this._state={paused:false,delayed:false,pauseQueue:new Set,resumeQueue:new Set,timeouts:new Set};this._pendingCalls=new
                Set;this._lastCallId=0;this._lastToId=0;this._memoizedDuration=0;if(!t.und(e)||!t.und(s)){const n=t.obj(e)?_extends({},e):_extends({},s,{from:e});t.und(n.default)&&(n.default=true);this.start(n)}}get idle(){return!(isAnimating(this)||this._state.asyncTo)||isPaused(this)}get
                goal(){return n(this.animation.to)}get velocity(){const t=F(this);return t instanceof M?t.lastVelocity||0:t.getPayload().map((t=>t.lastVelocity||0))}get hasAnimated(){return hasAnimated(this)}get isAnimating(){return isAnimating(this)}get
                isPaused(){return isPaused(this)}get isDelayed(){return this._state.delayed}advance(s){let i=true;let o=false;const r=this.animation;let{config:a,toValues:c}=r;const u=Q(r.to);!u&&m(r.to)&&(c=e(n(r.to)));r.values.forEach(((e,n)=>{if(e.done)return;const
                l=e.constructor==L?1:u?u[n].lastPosition:c[n];let d=r.immediate;let h=l;if(!d){h=e.lastPosition;if(a.tension
                <=0){e.done=true;return}let i=e.elapsedTime+=s;const o=r.fromValues[n];const c=null!=e.v0?e.v0:e.v0=t.arr(a.velocity)?a.velocity[n]:a.velocity;let
                    u;const f=a.precision||(o==l?.005:Math.min(1,.001*Math.abs(l-o)));if(t.und(a.duration))if(a.decay){const t=true===a.decay?.998:a.decay;const s=Math.exp(-(1-t)*i);h=o+c/(1-t)*(1-s);d=Math.abs(e.lastPosition-h)<=f;u=c*s}else{u=null==e.lastVelocity?c:e.lastVelocity;const
                    n=a.restVelocity||f/10;const i=a.clamp?0:a.bounce;const r=!t.und(i);const p=o==l?e.v0>0:o
                    <l;let m;let g=false;const y=1;const _=Math.ceil(s/y);for(let t=0;t<_;++t){m=Math.abs(u)>n;if(!m){d=Math.abs(l-h)
                        <=f;if(d)break}if(r){g=h==l||h>l==p;if(g){u=-u*i;h=l}}const t=1e-6*-a.tension*(h-l);const e=.001*-a.friction*u;const s=(t+e)/a.mass;u+=s*y;h+=u*y}}else{let t=1;if(a.duration>0){if(this._memoizedDuration!==a.duration){this._memoizedDuration=a.duration;if(e.durationProgress>0){e.elapsedTime=a.duration*e.durationProgress;i=e.elapsedTime+=s}}t=(a.progress||0)+i/this._memoizedDuration;t=t>1?1:t
                            <0?0:t;e.durationProgress=t}h=o+a.easing(t)*(l-o);u=(h-e.lastPosition)/s;d=1==t}e.lastVelocity=u;if(Number.isNaN(h)){console.warn(
                                "Got NaN while animating:",this);d=true}}u&&!u[n].done&&(d=false);d?e.done=true:i=false;e.setValue(h,a.round)&&(o=true)}));const l=F(this);const d=l.getValue();if(i){const t=n(r.to);if(d===t&&!o||a.decay)o&&a.decay&&this._onChange(d);else{l.setValue(t);this._onChange(t)}this._stop()}else
                                o&&this._onChange(d)}set(t){u.batchedUpdates((()=>{this._stop();this._focus(t);this._set(t)}));return this}pause(){this._update({pause:true})}resume(){this._update({pause:false})}finish(){if(isAnimating(this)){const{to:t,config:e}=this.animation;u.batchedUpdates((()=>{this._onStart();e.decay||this._set(t,false);this._stop()}))}return
                                this}update(t){const e=this.queue||(this.queue=[]);e.push(t);return this}start(e,s){let n;if(t.und(e)){n=this.queue||[];this.queue=[]}else n=[t.obj(e)?e:_extends({},s,{to:e})];return Promise.all(n.map((t=>{const e=this._update(t);return
                                e}))).then((t=>getCombinedResult(this,t)))}stop(t){const{to:e}=this.animation;this._focus(this.get());stopAsync(this._state,t&&this._lastCallId);u.batchedUpdates((()=>this._stop(e,t)));return this}reset(){this._update({reset:true})}eventObserved(t){"change"==t.type?this._start():"priority"==t.type&&(this.priority=t.priority+1)}_prepareNode(e){const
                                s=this.key||"";let{to:i,from:o}=e;i=t.obj(i)?i[s]:i;(null==i||isAsyncTo(i))&&(i=void 0);o=t.obj(o)?o[s]:o;null==o&&(o=void 0);const r={to:i,from:o};if(!hasAnimated(this)){e.reverse&&([i,o]=[o,i]);o=n(o);t.und(o)?F(this)||this._set(i):this._set(o)}return
                                r}_update(t,e){let s=_extends({},t);const{key:n,defaultProps:i}=this;s.default&&Object.assign(i,getDefaultProps(s,((t,e)=>/^on/.test(e)?resolveProp(t,n):t)));mergeActiveFn(this,s,"onProps");sendEvent(this,"onProps",s,this);const
                                o=this._prepareNode(s);if(Object.isFrozen(this))throw Error("Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?");const r=this._state;return
                                scheduleProps(++this._lastCallId,{key:n,props:s,defaultProps:i,state:r,actions:{pause:()=>{if(!isPaused(this)){setPausedBit(this,true);g(r.pauseQueue);sendEvent(this,"onPause",getFinishedResult(this,checkFinished(this,this.animation.to)),this)}},resume:()=>{if(isPaused(this)){setPausedBit(this,false);isAnimating(this)&&this._resume();g(r.resumeQueue);sendEvent(this,"onResume",getFinishedResult(this,checkFinished(this,this.animation.to)),this)}},start:this._merge.bind(this,o)}}).then((t=>{if(s.loop&&t.finished&&!(e&&t.noop)){const
                                t=createLoopUpdate(s);if(t)return this._update(t,true)}return t}))}_merge(s,o,r){if(o.cancel){this.stop(true);return r(getCancelledResult(this))}const c=!t.und(s.to);const l=!t.und(s.from);if(c||l){if(!(o.callId>this._lastToId))return
                                r(getCancelledResult(this));this._lastToId=o.callId}const{key:d,defaultProps:h,animation:f}=this;const{to:p,from:_}=f;let{to:v=p,from:P=_}=s;!l||c||o.default&&!t.und(v)||(v=P);o.reverse&&([v,P]=[P,v]);const b=!y(P,_);b&&(f.from=P);P=n(P);const
                                S=!y(v,p);S&&this._focus(v);const w=isAsyncTo(o.to);const{config:x}=f;const{decay:I,velocity:k}=x;(c||l)&&(x.velocity=0);o.config&&!w&&mergeConfig(x,callProp(o.config,d),o.config!==h.config?callProp(h.config,d):void 0);let
                                A=F(this);if(!A||t.und(v))return r(getFinishedResult(this,true));const C=t.und(o.reset)?l&&!o.default:!t.und(P)&&matchProp(o.reset,d);const T=C?P:this.get();const R=computeGoal(v);const E=t.num(R)||t.arr(R)||i(R);const
                                V=!w&&(!E||matchProp(h.immediate||o.immediate,d));if(S){const t=N(v);if(t!==A.constructor){if(!V)throw Error(`Cannot animate between ${A.constructor.name} and ${t.name}, as the "to" prop suggests`);A=this._set(R)}}const
                                j=A.constructor;let U=m(v);let O=false;if(!U){const t=C||!hasAnimated(this)&&b;if(S||t){O=y(computeGoal(T),R);U=!O}(y(f.immediate,V)||V)&&y(x.decay,I)&&y(x.velocity,k)||(U=true)}O&&isAnimating(this)&&(f.changed&&!C?U=true:U||this._stop(p));if(!w){if(U||m(p)){f.values=A.getPayload();f.toValues=m(v)?null:j==L?[1]:e(R)}if(f.immediate!=V){f.immediate=V;V||C||this._set(p)}if(U){const{onRest:t}=f;a(Z,(t=>mergeActiveFn(this,o,t)));const
                                e=getFinishedResult(this,checkFinished(this,p));g(this._pendingCalls,e);this._pendingCalls.add(r);f.changed&&u.batchedUpdates((()=>{f.changed=!C;null==t?void 0:t(e,this);C?callProp(h.onRest,e):null==f.onStart?void 0:f.onStart(e,this)}))}}C&&this._set(T);w?r(runAsync(o.to,o,this._state,this)):U?this._start():isAnimating(this)&&!S?this._pendingCalls.add(r):r(getNoopResult(T))}_focus(t){const
                                e=this.animation;if(t!==e.to){_(this)&&this._detach();e.to=t;_(this)&&this._attach()}}_attach(){let t=0;const{to:e}=this.animation;if(m(e)){v(e,this);isFrameValue(e)&&(t=e.priority+1)}this.priority=t}_detach(){const{to:t}=this.animation;m(t)&&P(t,this)}_set(e,s=true){const
                                i=n(e);if(!t.und(i)){const t=F(this);if(!t||!y(i,t.getValue())){const e=N(i);t&&t.constructor==e?t.setValue(i):z(this,e.create(i));t&&u.batchedUpdates((()=>{this._onChange(i,s)}))}}return F(this)}_onStart(){const t=this.animation;if(!t.changed){t.changed=true;sendEvent(this,"onStart",getFinishedResult(this,checkFinished(this,t.to)),this)}}_onChange(t,e){if(!e){this._onStart();callProp(this.animation.onChange,t,this)}callProp(this.defaultProps.onChange,t,this);super._onChange(t,e)}_start(){const
                                t=this.animation;F(this).reset(n(t.to));t.immediate||(t.fromValues=t.values.map((t=>t.lastPosition)));if(!isAnimating(this)){setActiveBit(this,true);isPaused(this)||this._resume()}}_resume(){o.skipAnimation?this.finish():p.start(this)}_stop(t,e){if(isAnimating(this)){setActiveBit(this,false);const
                                s=this.animation;a(s.values,(t=>{t.done=true}));s.toValues&&(s.onChange=s.onPause=s.onResume=void 0);f(this,{type:"idle",parent:this});const n=e?getCancelledResult(this.get()):getFinishedResult(this.get(),checkFinished(this,null!=t?t:s.to));g(this._pendingCalls,n);if(s.changed){s.changed=false;sendEvent(this,"onRest",n,this)}}}}function
                                checkFinished(t,e){const s=computeGoal(e);const n=computeGoal(t.get());return y(n,s)}function createLoopUpdate(t,e=t.loop,s=t.to){let n=callProp(e);if(n){const i=true!==n&&inferTo(n);const o=(i||t).reverse;const r=!i||i.reset;return
                                createUpdate(_extends({},t,{loop:e,default:false,pause:void 0,to:!o||isAsyncTo(s)?s:void 0,from:r?t.from:void 0,reset:r},i))}}function createUpdate(e){const{to:s,from:n}=e=inferTo(e);const i=new Set;t.obj(s)&&findDefined(s,i);t.obj(n)&&findDefined(n,i);e.keys=i.size?Array.from(i):null;return
                                e}function declareUpdate(e){const s=createUpdate(e);t.und(s.default)&&(s.default=getDefaultProps(s));return s}function findDefined(t,e){s(t,((t,s)=>null!=t&&e.add(s)))}const Z=["onStart","onRest","onChange","onPause","onResume"];function
                                mergeActiveFn(t,e,s){t.animation[s]=e[s]!==getDefaultProp(e,s)?resolveProp(e[s],t.key):void 0}function sendEvent(t,e,...s){var n,i,o,r;null==(n=(i=t.animation)[e])?void 0:n.call(i,...s);null==(o=(r=t.defaultProps)[e])?void
                                0:o.call(r,...s)}const tt=["onStart","onChange","onRest"];let et=1;class Controller{constructor(t,e){this.id=et++;this.springs={};this.queue=[];this.ref=void 0;this._flush=void 0;this._initialProps=void 0;this._lastAsyncId=0;this._active=new
                                Set;this._changed=new Set;this._started=false;this._item=void 0;this._state={paused:false,pauseQueue:new Set,resumeQueue:new Set,timeouts:new Set};this._events={onStart:new Map,onChange:new Map,onRest:new Map};this._onFrame=this._onFrame.bind(this);e&&(this._flush=e);t&&this.start(_extends({default:true},t))}get
                                idle(){return!this._state.asyncTo&&Object.values(this.springs).every((t=>t.idle&&!t.isDelayed&&!t.isPaused))}get item(){return this._item}set item(t){this._item=t}get(){const t={};this.each(((e,s)=>t[s]=e.get()));return
                                t}set(e){for(const s in e){const n=e[s];t.und(n)||this.springs[s].set(n)}}update(t){t&&this.queue.push(createUpdate(t));return this}start(t){let{queue:s}=this;t?s=e(t).map(createUpdate):this.queue=[];if(this._flush)return
                                this._flush(this,s);prepareKeys(this,s);return flushUpdateQueue(this,s)}stop(t,s){t!==!!t&&(s=t);if(s){const n=this.springs;a(e(s),(e=>n[e].stop(!!t)))}else{stopAsync(this._state,this._lastAsyncId);this.each((e=>e.stop(!!t)))}return
                                this}pause(s){if(t.und(s))this.start({pause:true});else{const t=this.springs;a(e(s),(e=>t[e].pause()))}return this}resume(s){if(t.und(s))this.start({pause:false});else{const t=this.springs;a(e(s),(e=>t[e].resume()))}return
                                this}each(t){s(this.springs,t)}_onFrame(){const{onStart:t,onChange:e,onRest:s}=this._events;const n=this._active.size>0;const i=this._changed.size>0;if(n&&!this._started||i&&!this._started){this._started=true;l(t,(([t,e])=>{e.value=this.get();t(e,this,this._item)}))}const
                                o=!n&&this._started;const r=i||o&&s.size?this.get():null;i&&e.size&&l(e,(([t,e])=>{e.value=r;t(e,this,this._item)}));if(o){this._started=false;l(s,(([t,e])=>{e.value=r;t(e,this,this._item)}))}}eventObserved(t){if("change"==t.type){this._changed.add(t.parent);t.idle||this._active.add(t.parent)}else{if("idle"!=t.type)return;this._active.delete(t.parent)}u.onFrame(this._onFrame)}}function
                                flushUpdateQueue(t,e){return Promise.all(e.map((e=>flushUpdate(t,e)))).then((e=>getCombinedResult(t,e)))}async function flushUpdate(e,s,n){const{keys:i,to:o,from:r,loop:c,onRest:l,onResolve:d}=s;const h=t.obj(s.default)&&s.default;c&&(s.loop=false);false===o&&(s.to=null);false===r&&(s.from=null);const
                                f=t.arr(o)||t.fun(o)?o:void 0;if(f){s.to=void 0;s.onRest=void 0;h&&(h.onRest=void 0)}else a(tt,(n=>{const i=s[n];if(t.fun(i)){const t=e._events[n];s[n]=({finished:e,cancelled:s})=>{const n=t.get(i);if(n){e||(n.finished=false);s&&(n.cancelled=true)}else
                                t.set(i,{value:null,finished:e||false,cancelled:s||false})};h&&(h[n]=s[n])}}));const p=e._state;if(s.pause===!p.paused){p.paused=s.pause;g(s.pause?p.pauseQueue:p.resumeQueue)}else p.paused&&(s.pause=true);const m=(i||Object.keys(e.springs)).map((t=>e.springs[t].start(s)));const
                                y=true===s.cancel||true===getDefaultProp(s,"cancel");(f||y&&p.asyncId)&&m.push(scheduleProps(++e._lastAsyncId,{props:s,state:p,actions:{pause:b,resume:b,start(t,s){if(y){stopAsync(p,e._lastAsyncId);s(getCancelledResult(e))}else{t.onRest=l;s(runAsync(f,t,p,e))}}}}));p.paused&&await
                                new Promise((t=>{p.resumeQueue.add(t)}));const _=getCombinedResult(e,await Promise.all(m));if(c&&_.finished&&!(n&&_.noop)){const t=createLoopUpdate(s,c,o);if(t){prepareKeys(e,[t]);return flushUpdate(e,t,true)}}d&&u.batchedUpdates((()=>d(_,e,e.item)));return
                                _}function getSprings(s,n){const i=_extends({},s.springs);n&&a(e(n),(e=>{t.und(e.keys)&&(e=createUpdate(e));t.obj(e.to)||(e=_extends({},e,{to:void 0}));prepareSprings(i,e,(t=>createSpring(t)))}));setSprings(s,i);return
                                i}function setSprings(t,e){s(e,((e,s)=>{if(!t.springs[s]){t.springs[s]=e;v(e,t)}}))}function createSpring(t,e){const s=new SpringValue;s.key=t;e&&v(s,e);return s}function prepareSprings(t,e,s){e.keys&&a(e.keys,(n=>{const
                                i=t[n]||(t[n]=s(n));i._prepareNode(e)}))}function prepareKeys(t,e){a(e,(e=>{prepareSprings(t.springs,e,(e=>createSpring(e,t)))}))}function _objectWithoutPropertiesLoose(t,e){if(null==t)return{};var s={};var n=Object.keys(t);var
                                i,o;for(o=0;o
                                <n.length;o++){i=n[o];e.indexOf(i)>=0||(s[i]=t[i])}return s}const st=["children"];const SpringContext=t=>{let{children:e}=t,s=_objectWithoutPropertiesLoose(t,st);const n=j(nt);const i=s.pause||!!n.pause,o=s.immediate||!!n.immediate;s=S((()=>({pause:i,immediate:o})),[i,o]);const{Provider:r}=nt;return
                                    V.createElement(r,{value:s},e)};const nt=makeContext(SpringContext,{});SpringContext.Provider=nt.Provider;SpringContext.Consumer=nt.Consumer;function makeContext(t,e){Object.assign(t,V.createContext(e));t.Provider._context=t;t.Consumer._context=t;return
                                    t}const SpringRef=()=>{const e=[];const s=function SpringRef(s){w();const i=[];a(e,((e,o)=>{if(t.und(s))i.push(e.start());else{const t=n(s,e,o);t&&i.push(e.start(t))}}));return i};s.current=e;s.add=function(t){e.includes(t)||e.push(t)};s.delete=function(t){const
                                    s=e.indexOf(t);~s&&e.splice(s,1)};s.pause=function(){a(e,(t=>t.pause(...arguments)));return this};s.resume=function(){a(e,(t=>t.resume(...arguments)));return this};s.set=function(t){a(e,(e=>e.set(t)))};s.start=function(s){const
                                    n=[];a(e,((e,i)=>{if(t.und(s))n.push(e.start());else{const t=this._getProps(s,e,i);t&&n.push(e.start(t))}}));return n};s.stop=function(){a(e,(t=>t.stop(...arguments)));return this};s.update=function(t){a(e,((e,s)=>e.update(this._getProps(t,e,s))));return
                                    this};const n=function _getProps(e,s,n){return t.fun(e)?e(n,s):e};s._getProps=n;return s};function useSprings(e,s,n){const i=t.fun(s)&&s;i&&!n&&(n=[]);const o=U((()=>i||3==arguments.length?SpringRef():void 0),[]);const
                                    c=O(0);const u=x();const l=U((()=>({ctrls:[],queue:[],flush(t,e){const s=getSprings(t,e);const n=c.current>0&&!l.queue.length&&!Object.keys(s).some((e=>!t.springs[e]));return n?flushUpdateQueue(t,e):new Promise((n=>{setSprings(t,s);l.queue.push((()=>{n(flushUpdateQueue(t,e))}));u()}))}})),[]);const
                                    d=O([...l.ctrls]);const h=[];const f=I(e)||0;U((()=>{a(d.current.slice(e,f),(t=>{detachRefs(t,o);t.stop(true)}));d.current.length=e;declareUpdates(f,e)}),[e]);U((()=>{declareUpdates(0,Math.min(f,e))}),n);function declareUpdates(t,e){for(let
                                    n=t;n
                                    <e;n++){const t=d.current[n]||(d.current[n]=new Controller(null,l.flush));const e=i?i(n,t):s[n];e&&(h[n]=declareUpdate(e))}}const p=d.current.map(((t,e)=>getSprings(t,h[e])));const m=j(SpringContext);const g=I(m);const y=m!==g&&hasProps(m);r((()=>{c.current++;l.ctrls=d.current;const{queue:t}=l;if(t.length){l.queue=[];a(t,(t=>t()))}a(d.current,((t,e)=>{null==o?void 0:o.add(t);y&&t.start({default:m});const
                                        s=h[e];if(s){replaceRef(t,s.ref);t.ref?t.queue.push(s):t.start(s)}}))}));k((()=>()=>{a(l.ctrls,(t=>t.stop(true)))}));const _=p.map((t=>_extends({},t)));return o?[_,o]:_}function useSpring(e,s){const n=t.fun(e);const[[i],o]=useSprings(1,n?e:[e],n?s||[]:s);return
                                        n||2==arguments.length?[i,o]:i}const initSpringRef=()=>SpringRef();const useSpringRef=()=>q(initSpringRef)[0];const useSpringValue=(t,e)=>{const s=A((()=>new SpringValue(t,e)));k((()=>()=>{s.stop()}));return s};function
                                        useTrail(e,s,n){const i=t.fun(s)&&s;i&&!n&&(n=[]);let o=true;let c;const u=useSprings(e,((t,e)=>{const n=i?i(t,e):s;c=n.ref;o=o&&n.reverse;return n}),n||[{}]);r((()=>{a(u[1].current,((t,e)=>{const s=u[1].current[e+(o?1:-1)];replaceRef(t,c);t.ref?s&&t.update({to:s.springs}):s?t.start({to:s.springs}):t.start()}))}),n);if(i||3==arguments.length){var
                                        l;const e=null!=(l=c)?l:u[1];e._getProps=(s,n,i)=>{const o=t.fun(s)?s(i,n):s;if(o){const t=e.current[i+(o.reverse?1:-1)];t&&(o.to=t.springs);return o}};return u}return u[0]}let it;(function(t){t.MOUNT="mount";t.ENTER="enter";t.UPDATE="update";t.LEAVE="leave"})(it||(it={}));function
                                        useTransition(s,n,i){const o=t.fun(n)&&n;const{reset:c,sort:u,trail:l=0,expires:d=true,exitBeforeEnter:h=false,onDestroyed:f,ref:p,config:m}=o?o():n;const g=U((()=>o||3==arguments.length?SpringRef():void 0),[]);const
                                        y=e(s);const _=[];const v=O(null);const P=c?null:v.current;r((()=>{v.current=_}));k((()=>{a(_,(t=>{null==g?void 0:g.add(t.ctrl);t.ctrl.ref=g}));return()=>{a(v.current,(t=>{t.expired&&clearTimeout(t.expirationId);detachRefs(t.ctrl,g);t.ctrl.stop(true)}))}}));const
                                        b=getKeys(y,o?o():n,P);const S=c&&v.current||[];r((()=>a(S,(({ctrl:t,item:e,key:s})=>{detachRefs(t,g);callProp(f,e,s)}))));const w=[];P&&a(P,((t,e)=>{if(t.expired){clearTimeout(t.expirationId);S.push(t)}else{e=w[e]=b.indexOf(t.key);~e&&(_[e]=t)}}));a(y,((t,e)=>{if(!_[e]){_[e]={key:b[e],item:t,phase:it.MOUNT,ctrl:new
                                        Controller};_[e].ctrl.item=t}}));if(w.length){let t=-1;const{leave:e}=o?o():n;a(w,((s,n)=>{const i=P[n];if(~s){t=_.indexOf(i);_[t]=_extends({},i,{item:y[s]})}else e&&_.splice(++t,0,i)}))}t.fun(u)&&_.sort(((t,e)=>u(t.item,e.item)));let
                                        A=-l;const C=x();const T=getDefaultProps(n);const R=new Map;const E=O(new Map);const q=O(false);a(_,((e,s)=>{const i=e.key;const r=e.phase;const a=o?o():n;let c;let u;let f=callProp(a.delay||0,i);if(r==it.MOUNT){c=a.enter;u=it.ENTER}else{const
                                        t=b.indexOf(i)
                                        <0;if(r!=it.LEAVE)if(t){c=a.leave;u=it.LEAVE}else{if(!(c=a.update))return;u=it.UPDATE}else{if(t)return;c=a.enter;u=it.ENTER}}c=callProp(c,e.item,s);c=t.obj(c)?inferTo(c):{to:c};if(!c.config){const
                                            t=m||T.config;c.config=callProp(t,e.item,s,u)}A+=l;const g=_extends({},T,{delay:f+A,ref:p,immediate:a.immediate,reset:false},c);if(u==it.ENTER&&t.und(g.from)){const i=o?o():n;const r=t.und(i.initial)||P?i.from:i.initial;g.from=callProp(r,e.item,s)}const{onResolve:y}=g;g.onResolve=t=>{callProp(y,t);const e=v.current;const s=e.find((t=>t.key===i));if(s&&(!t.cancelled||s.phase==it.UPDATE)&&s.ctrl.idle){const t=e.every((t=>t.ctrl.idle));if(s.phase==it.LEAVE){const e=callProp(d,s.item);if(false!==e){const
                                            n=true===e?0:e;s.expired=true;if(!t&&n>0){n
                                            <=2147483647&&(s.expirationId=setTimeout(C,n));return}}}if(t&&e.some((t=>t.expired))){E.current.delete(s);h&&(q.current=true);C()}}};const _=getSprings(e.ctrl,g);u===it.LEAVE&&h?E.current.set(e,{phase:u,springs:_,payload:g}):R.set(e,{phase:u,springs:_,payload:g})}));const F=j(SpringContext);const
                                                M=I(F);const Q=F!==M&&hasProps(F);r((()=>{Q&&a(_,(t=>{t.ctrl.start({default:F})}))}),[F]);a(R,((t,e)=>{if(E.current.size){const t=_.findIndex((t=>t.key===e.key));_.splice(t,1)}}));r((()=>{a(E.current.size?E.current:R,(({phase:t,payload:e},s)=>{const{ctrl:n}=s;s.phase=t;null==g?void
                                                0:g.add(n);Q&&t==it.ENTER&&n.start({default:F});if(e){replaceRef(n,e.ref);if(!n.ref&&!g||q.current){n.start(e);q.current&&(q.current=false)}else n.update(e)}}))}),c?void 0:i);const renderTransitions=e=>V.createElement(V.Fragment,null,_.map(((s,n)=>{const{springs:i}=R.get(s)||s.ctrl;const
                                                o=e(_extends({},i),s.item,s,n);return o&&o.type?V.createElement(o.type,_extends({},o.props,{key:t.str(s.key)||t.num(s.key)?s.key:s.ctrl.id,ref:o.ref})):o})));return g?[renderTransitions,g]:renderTransitions}let
                                                ot=1;function getKeys(s,{key:n,keys:i=n},o){if(null===i){const t=new Set;return s.map((e=>{const s=o&&o.find((s=>s.item===e&&s.phase!==it.LEAVE&&!t.has(s)));if(s){t.add(s);return s.key}return ot++}))}return
                                                t.und(i)?s:t.fun(i)?s.map(i):e(i)}const rt=["container"];const useScroll=(t={})=>{let{container:e}=t,s=_objectWithoutPropertiesLoose(t,rt);const[n,i]=useSpring((()=>_extends({scrollX:0,scrollY:0,scrollXProgress:0,scrollYProgress:0},s)),[]);r((()=>{const
                                                t=C((({x:t,y:e})=>{i.start({scrollX:t.current,scrollXProgress:t.progress,scrollY:e.current,scrollYProgress:e.progress})}),{container:(null==e?void 0:e.current)||void 0});return()=>{a(Object.values(n),(t=>t.stop()));t()}}),[]);return
                                                n};const at=["container"];const useResize=t=>{let{container:e}=t,s=_objectWithoutPropertiesLoose(t,at);const[n,i]=useSpring((()=>_extends({width:0,height:0},s)),[]);r((()=>{const t=T((({width:t,height:e})=>{i.start({width:t,height:e,immediate:0===n.width.get()||0===n.height.get()})}),{container:(null==e?void
                                                0:e.current)||void 0});return()=>{a(Object.values(n),(t=>t.stop()));t()}}),[]);return n};const ct=["to","from"],ut=["root","once","amount"];const lt={any:0,all:1};function useInView(e,s){const[n,i]=q(false);const
                                                o=O();const a=t.fun(e)&&e;const c=a?a():{};const{to:u={},from:l={}}=c,d=_objectWithoutPropertiesLoose(c,ct);const h=a?s:e;const[f,p]=useSpring((()=>_extends({from:l},d)),[]);r((()=>{const e=o.current;const
                                                s=null!=h?h:{},{root:r,once:a,amount:c="any"}=s,d=_objectWithoutPropertiesLoose(s,ut);if(!e||a&&n||"undefined"===typeof IntersectionObserver)return;const f=new WeakMap;const onEnter=()=>{u&&p.start(u);i(true);const
                                                cleanup=()=>{l&&p.start(l);i(false)};return a?void 0:cleanup};const handleIntersection=e=>{e.forEach((e=>{const s=f.get(e.target);if(e.isIntersecting!==Boolean(s))if(e.isIntersecting){const s=onEnter();t.fun(s)?f.set(e.target,s):m.unobserve(e.target)}else
                                                if(s){s();f.delete(e.target)}}))};const m=new IntersectionObserver(handleIntersection,_extends({root:r&&r.current||void 0,threshold:"number"===typeof c||Array.isArray(c)?c:lt[c]},d));m.observe(e);return()=>m.unobserve(e)}),[h]);return
                                                a?[o,f]:[o,n]}const dt=["children"];function Spring(t){let{children:e}=t,s=_objectWithoutPropertiesLoose(t,dt);return e(useSpring(s))}const ht=["items","children"];function Trail(e){let{items:s,children:n}=e,i=_objectWithoutPropertiesLoose(e,ht);const
                                                o=useTrail(s.length,i);return s.map(((e,s)=>{const i=n(e,s);return t.fun(i)?i(o[s]):i}))}const ft=["items","children"];function Transition(t){let{items:e,children:s}=t,n=_objectWithoutPropertiesLoose(t,ft);return
                                                useTransition(e,n)(s)}class Interpolation extends FrameValue{constructor(t,e){super();this.key=void 0;this.idle=true;this.calc=void 0;this._active=new Set;this.source=t;this.calc=R(...e);const s=this._get();const
                                                n=N(s);z(this,n.create(s))}advance(t){const e=this._get();const s=this.get();if(!y(e,s)){F(this).setValue(e);this._onChange(e,this.idle)}!this.idle&&checkIdle(this._active)&&becomeIdle(this)}_get(){const
                                                s=t.arr(this.source)?this.source.map(n):e(n(this.source));return this.calc(...s)}_start(){if(this.idle&&!checkIdle(this._active)){this.idle=false;a(Q(this),(t=>{t.done=false}));if(o.skipAnimation){u.batchedUpdates((()=>this.advance()));becomeIdle(this)}else
                                                p.start(this)}}_attach(){let t=1;a(e(this.source),(e=>{m(e)&&v(e,this);if(isFrameValue(e)){e.idle||this._active.add(e);t=Math.max(t,e.priority+1)}}));this.priority=t;this._start()}_detach(){a(e(this.source),(t=>{m(t)&&P(t,this)}));this._active.clear();becomeIdle(this)}eventObserved(t){if("change"==t.type)if(t.idle)this.advance();else{this._active.add(t.parent);this._start()}else"idle"==t.type?this._active.delete(t.parent):"priority"==t.type&&(this.priority=e(this.source).reduce(((t,e)=>Math.max(t,(isFrameValue(e)?e.priority:0)+1)),0))}}function
                                                isIdle(t){return false!==t.idle}function checkIdle(t){return!t.size||Array.from(t).every(isIdle)}function becomeIdle(t){if(!t.idle){t.idle=true;a(Q(t),(t=>{t.done=true}));f(t,{type:"idle",parent:t})}}const
                                                to=(t,...e)=>new Interpolation(t,e);const interpolate=(t,...e)=>(h(),new Interpolation(t,e));o.assign({createStringInterpolator:E,to:(t,e)=>new Interpolation(t,e)});const pt=p.advance;export{BailSignal,Controller,FrameValue,Interpolation,Spring,SpringContext,SpringRef,SpringValue,Trail,Transition,G
                                                as config,inferTo,interpolate,to,pt as update,useChain,useInView,useResize,useScroll,useSpring,useSpringRef,useSpringValue,useSprings,useTrail,useTransition}; //# sourceMappingURL=react-spring-core.esm.js.map