import{defineHidden as t,is as e,createInterpolator as n,eachProp as s,hasFluidValue as r,getFluidValue as a,each as i,isAnimatedString as o,useForceUpdate as u,useIsomorphicLayoutEffect as l,addFluidObserver as d,removeFluidObserver as c,raf as m,useOnce
as p}from"@react-spring/shared";import*as h from"react";import{forwardRef as A,useRef as g,useCallback as y,useEffect as f}from"react";const _=Symbol.for("Animated:node");const isAnimated=t=>!!t&&t[_]===t;const getAnimated=t=>t&&t[_];const setAnimated=(e,n)=>t(e,_,n);const
getPayload=t=>t&&t[_]&&t[_].getPayload();class Animated{constructor(){this.payload=void 0;setAnimated(this,this)}getPayload(){return this.payload||[]}}class AnimatedValue extends Animated{constructor(t){super();this.done=true;this.elapsedTime=void 0;this.lastPosition=void
0;this.lastVelocity=void 0;this.v0=void 0;this.durationProgress=0;this._value=t;e.num(this._value)&&(this.lastPosition=this._value)}static create(t){return new AnimatedValue(t)}getPayload(){return[this]}getValue(){return this._value}setValue(t,n){if(e.num(t)){this.lastPosition=t;if(n){t=Math.round(t/n)*n;this.done&&(this.lastPosition=t)}}if(this._value===t)return
false;this._value=t;return true}reset(){const{done:t}=this;this.done=false;if(e.num(this._value)){this.elapsedTime=0;this.durationProgress=0;this.lastPosition=this._value;t&&(this.lastVelocity=null);this.v0=null}}}class AnimatedString extends AnimatedValue{constructor(t){super(0);this._string=null;this._toString=void
0;this._toString=n({output:[t,t]})}static create(t){return new AnimatedString(t)}getValue(){let t=this._string;return null==t?this._string=this._toString(this._value):t}setValue(t){if(e.str(t)){if(t==this._string)return false;this._string=t;this._value=1}else{if(!super.setValue(t))return
false;this._string=null}return true}reset(t){t&&(this._toString=n({output:[this.getValue(),t]}));this._value=0;super.reset()}}const V={dependencies:null};class AnimatedObject extends Animated{constructor(t){super();this.source=t;this.setValue(t)}getValue(t){const
e={};s(this.source,((n,s)=>{isAnimated(n)?e[s]=n.getValue(t):r(n)?e[s]=a(n):t||(e[s]=n)}));return e}setValue(t){this.source=t;this.payload=this._makePayload(t)}reset(){this.payload&&i(this.payload,(t=>t.reset()))}_makePayload(t){if(t){const e=new Set;s(t,this._addToPayload,e);return
Array.from(e)}}_addToPayload(t){V.dependencies&&r(t)&&V.dependencies.add(t);const e=getPayload(t);e&&i(e,(t=>this.add(t)))}}class AnimatedArray extends AnimatedObject{constructor(t){super(t)}static create(t){return new AnimatedArray(t)}getValue(){return
this.source.map((t=>t.getValue()))}setValue(t){const e=this.getPayload();if(t.length==e.length)return e.map(((e,n)=>e.setValue(t[n]))).some(Boolean);super.setValue(t.map(makeAnimated));return true}}function makeAnimated(t){const e=o(t)?AnimatedString:AnimatedValue;return
e.create(t)}function getAnimatedType(t){const n=getAnimated(t);return n?n.constructor:e.arr(t)?AnimatedArray:o(t)?AnimatedString:AnimatedValue}function _extends(){_extends=Object.assign?Object.assign.bind():function(t){for(var e=1;e
<arguments.length;e++){var
    n=arguments[e];for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&(t[s]=n[s])}return t};return _extends.apply(this,arguments)}const withAnimated=(t,n)=>{const s=!e.fun(t)||t.prototype&&t.prototype.isReactComponent;return A(((e,r)=>{const a=g(null);const o=s&&y((t=>{a.current=updateRef(r,t)}),[r]);const[A,_]=getAnimatedState(e,n);const V=u();const callback=()=>{const t=a.current;if(s&&!t)return;const
    e=!!t&&n.applyAnimatedValues(t,A.getValue(true));false===e&&V()};const v=new PropsObserver(callback,_);const P=g();l((()=>{P.current=v;i(_,(t=>d(t,v)));return()=>{if(P.current){i(P.current.deps,(t=>c(t,P.current)));m.cancel(P.current.update)}}}));f(callback,[]);p((()=>()=>{const
    t=P.current;i(t.deps,(e=>c(e,t)))}));const S=n.getComponentProps(A.getValue());return h.createElement(t,_extends({},S,{ref:o}))}))};class PropsObserver{constructor(t,e){this.update=t;this.deps=e}eventObserved(t){"change"==t.type&&m.write(this.update)}}function
    getAnimatedState(t,e){const n=new Set;V.dependencies=n;t.style&&(t=_extends({},t,{style:e.createAnimatedStyle(t.style)}));t=new AnimatedObject(t);V.dependencies=null;return[t,n]}function updateRef(t,n){t&&(e.fun(t)?t(n):t.current=n);return n}const
    v=Symbol.for("AnimatedComponent");const createHost=(t,{applyAnimatedValues:n=(()=>false),createAnimatedStyle:r=(t=>new AnimatedObject(t)),getComponentProps:a=(t=>t)}={})=>{const i={applyAnimatedValues:n,createAnimatedStyle:r,getComponentProps:a};const
    animated=t=>{const n=getDisplayName(t)||"Anonymous";t=e.str(t)?animated[t]||(animated[t]=withAnimated(t,i)):t[v]||(t[v]=withAnimated(t,i));t.displayName=`Animated(${n})`;return t};s(t,((n,s)=>{e.arr(t)&&(s=getDisplayName(n));animated[s]=animated(n)}));return{animated:animated}};const
    getDisplayName=t=>e.str(t)?t:t&&e.str(t.displayName)?t.displayName:e.fun(t)&&t.name||null;export{Animated,AnimatedArray,AnimatedObject,AnimatedString,AnimatedValue,createHost,getAnimated,getAnimatedType,getPayload,isAnimated,setAnimated}; //# sourceMappingURL=react-spring-animated.esm.js.map